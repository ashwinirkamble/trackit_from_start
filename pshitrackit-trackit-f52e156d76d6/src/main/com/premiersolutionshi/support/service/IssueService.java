package com.premiersolutionshi.support.service;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionException;
import org.apache.struts.upload.FormFile;
import org.springframework.stereotype.Component;

import com.premiersolutionshi.common.constant.ManagedList;
import com.premiersolutionshi.common.domain.FileInfo;
import com.premiersolutionshi.common.domain.JoinDomain;
import com.premiersolutionshi.common.service.BulkDomainService;
import com.premiersolutionshi.common.service.FileInfoService;
import com.premiersolutionshi.common.service.ManagedListItemService;
import com.premiersolutionshi.common.service.UserService;
import com.premiersolutionshi.common.util.StringUtils;
import com.premiersolutionshi.support.constant.BulkIssueCategory;
import com.premiersolutionshi.support.constant.IssueStatus;
import com.premiersolutionshi.support.constant.MonthlyIssueCategory;
import com.premiersolutionshi.support.dao.IssueDao;
import com.premiersolutionshi.support.domain.ConfiguredSystem;
import com.premiersolutionshi.support.domain.ConfiguredSystemWithIssues;
import com.premiersolutionshi.support.domain.FkAndStringList;
import com.premiersolutionshi.support.domain.Issue;
import com.premiersolutionshi.support.domain.IssueCategory;
import com.premiersolutionshi.support.domain.IssueComments;
import com.premiersolutionshi.support.domain.IssueSupportVisit;
import com.premiersolutionshi.support.ui.form.BulkIssueForm;
import com.premiersolutionshi.support.ui.form.IssueForm;

import edu.emory.mathcs.backport.java.util.Arrays;

@Component("issueService")
public class IssueService extends BulkDomainService<Issue> {
    private static final String MONTHLY_EMAIL_COMMENT = "Reminder e-mail sent via Monthly E-Mail Notification module";
    private static final String MONTHLY_EMAIL_NOTIF = "Monthly E-Mail Notification: ";
    private static final String BULK_ISSUE_DEPT = "N/A";
    private static final String BULK_ISSUE_DESCRIPTION = "Auto-generated by the bulk e-mail / issue generation tool";
    private static final int DEFAULT_ISSUE_TOTAL_TIME = 15;

    private IssueCommentsService issueCommentsService;
    private FileInfoService fileInfoService;
    private ConfiguredSystemService configuredSystemService;
    private ManagedListItemService managedListItemService;
    private PocService pocService;
    private Map<String, IssueCategory> nameToIssueCategoryMap;

    public IssueService(SqlSession sqlSession, UserService userService, IssueCommentsService issueCommentsService, IssueCategoryService issueCategoryService,
            ConfiguredSystemService configuredSystemService, FileInfoService fileInfoService, ManagedListItemService managedListItemService,
            PocService pocService) {
        super(sqlSession, IssueDao.class, userService);
        this.configuredSystemService = configuredSystemService;
        this.issueCommentsService = issueCommentsService;
        this.fileInfoService = fileInfoService;
        this.managedListItemService = managedListItemService;
        this.pocService = pocService;
    }

    public boolean saveForm(IssueForm issueForm) {
        if (issueForm == null) {
            logError("No IssueForm was received");
            return false;
        }
        if (save(issueForm)) {
            Integer id = issueForm.getId();

            //handle issue comments and closing checked issues.
            String[] closeIssuePkArr = issueForm.getCloseIssuePkArr();
            String[] commentsArr = issueForm.getCommentsArr();
            @SuppressWarnings("unchecked")
            List<String> commentsList = commentsArr == null ? new ArrayList<>() : Arrays.asList(commentsArr);
            if (closeIssuePkArr != null && closeIssuePkArr.length > 0) {
                String supportVisitDateStr = issueForm.getSupportVisitDateStr();
                String personAssigned = getCurrentUser().getFullName();
                handleBulkCloseIssues(closeIssuePkArr, "Resolved during onsite visit " + supportVisitDateStr
                    + ". See Issue #" + id, personAssigned);
                String issuePksClosed = String.join(", #", closeIssuePkArr);
                commentsList.add("Also closed during onsite visit on " + supportVisitDateStr
                    + " Issue #" + issuePksClosed);
            }
            handleCommentList(commentsList, id);
            handleFileList(issueForm, id);
            handleDeleteFiles(issueForm.getDeleteFilePkArr(), id);
        }
        return true;
    }

    private void handleCommentList(List<String> commentsList, Integer id) {
        if (commentsList == null|| commentsList.size() <= 0) {
            return;
        }
        int size = commentsList.size();
        //need to reverse order since they are also displayed in descending order.
        for (int i = size - 1; i >= 0; i--) {
            String comments = commentsList.get(i).trim();
            if (!StringUtils.isEmpty(comments)) {
                IssueComments comment = new IssueComments();
                comment.setComments(comments);
                comment.setIssueFk(id);
                issueCommentsService.save(comment);
            }
        }
    }

    private void handleFileList(IssueForm issueForm, Integer issueFk) {
        ArrayList<FormFile> formFileList = issueForm.getFileList();
        if (formFileList == null|| formFileList.isEmpty()) {
            return;
        }
        ArrayList<FileInfo> fileInfoList = fileInfoService.saveFormFileList(formFileList);
        if (fileInfoList != null && !fileInfoList.isEmpty()) {
            ArrayList<JoinDomain> joinList = new ArrayList<>();
            for (FileInfo fileInfo : fileInfoList) {
                Integer fileFk = fileInfo.getId();
                joinList.add(new JoinDomain(fileFk, issueFk));
            }
            insertMultipleFileJoins(joinList);
        }
        issueForm.setIssueFileList(fileInfoList);
    }

    /**
     * Inserting one at a time is causing the database to lock.
     * @param joinList
     */
    private void insertMultipleFileJoins(ArrayList<JoinDomain> joinList) {
        if (joinList == null || joinList.isEmpty()) {
            return;
        }
        try {
            if (getDao().insertMultipleFileJoins(joinList) > 0) {
                logInfo("Successfully inserted: joinList.size()=" + joinList.size());
            }
        }
        catch (Exception e) {
            logError("Failed to insertMultipleFileJoins.", e);
        }
    }

    private void handleDeleteFiles(String[] deleteFilePkArr, Integer id) {
        if (deleteFilePkArr == null || deleteFilePkArr.length <= 0) {
            return;
        }
        for (String filePk : deleteFilePkArr) {
            Integer filePkInt = StringUtils.parseInt(filePk);
            if (deleteFileJoin(filePkInt, id)) {
                fileInfoService.deleteById(filePkInt);
            }
        }
    }

    private boolean deleteFileJoin(Integer filePk, Integer id) {
        boolean success = false;
        String errorMessage = "Could not deleteFileJoin. filePk=" + filePk + ", id=" + id;
        try {
            if (getDao().deleteFileJoin(filePk, id) == 1) {
                logInfo("Successfully deleteFileJoin: filePk=" + filePk + ", id=" + id);
                success = true;
            }
            else {
                logError(errorMessage);
            }
        }
        catch (Exception e) {
            logError(errorMessage, e);
        }
        return success;
    }

    @Override
    public IssueDao getDao() {
        return (IssueDao) super.getDao();
    }

    @Override
    protected void beforeSave(Issue domain) {
        if (domain == null) {
            return;
        }
        super.beforeSave(domain);
        domain.setTitle(StringUtils.escapeHtml(domain.getTitle()));
        domain.setDescription(StringUtils.escapeHtml(domain.getDescription()));
        domain.setResolution(StringUtils.escapeHtml(domain.getResolution()));
        domain.setSupportVisitLocNotes(StringUtils.escapeHtml(domain.getSupportVisitLocNotes()));

        domain.setDept(StringUtils.removeXss(domain.getDept()));
        domain.setSupportVisitLoc(StringUtils.removeXss(domain.getSupportVisitLoc()));
        domain.setPersonAssigned(StringUtils.removeXss(domain.getPersonAssigned()));
        domain.setLaptopIssue(StringUtils.removeXss(domain.getLaptopIssue()));
        domain.setScannerIssue(StringUtils.removeXss(domain.getScannerIssue()));
        domain.setSoftwareIssue(StringUtils.removeXss(domain.getSoftwareIssue()));
        domain.setInitiatedBy(StringUtils.removeXss(domain.getInitiatedBy()));

        if (domain.getSupportVisitDate() == null) {
            domain.setTrainer(null);
            domain.setSupportVisitTime(null);
            domain.setSupportVisitEndTime(null);
            domain.setSupportVisitReason(null);
            domain.setSupportVisitLoc(null);
            domain.setSupportVisitLocNotes(null);
        }
        if (domain.getStatusCode() < IssueStatus.CLOSED.getCode()) {
            domain.setClosedDate(null);
        }
        else {
            //if the issue is closed and no closed date is set, set the closed date to today.
            if (domain.getClosedDate() == null) {
                domain.setClosedDate(LocalDate.now());
            }
            
        }
        handleUpdatingConfiguredSystem(domain);
    }

    /**
     * If the issue is:
     * -- closed
     * -- is a "FACET Update" or "OS Update" Category
     * -- previously NOT closed
     * THEN update Configured System with the new FACET or OS version
     * @param issue
     */
    private void handleUpdatingConfiguredSystem(Issue issue) {
        Integer configuredSystemFk = issue.getConfiguredSystemFk();
        Integer issueCategoryFk = issue.getIssueCategoryFk();
        if (issue.isClosed() && configuredSystemFk != null && issue.getId() != null && issueCategoryFk != null) {
            String categoryName = issue.getCategory();
            boolean isFacetVersionIssue = categoryName.equals(MonthlyIssueCategory.FACET.getName());
            boolean isOsVersionIssue = categoryName.equals(MonthlyIssueCategory.OS.getName());
            if (isFacetVersionIssue || isOsVersionIssue) {
                Issue previous = getById(issue.getId());//get previous record
                //if it wasn't previously closed, let's see if it has the latest FACET version.
                if (previous != null && !previous.isClosed()) {
                    Integer projectFk = issue.getProjectFk();
                    if (isFacetVersionIssue) {
                        String currFacetVersion = managedListItemService.getCurrentDefault(ManagedList.FACET_VERSIONS, projectFk);
                        handleUpdatingFacetVersion(issue, currFacetVersion);
                    }
                    if (isOsVersionIssue) {
                        String currOsVersion = managedListItemService.getCurrentDefault(ManagedList.OS_VERSIONS, projectFk);
                        handleUpdatingOsVersion(issue, currOsVersion);
                    }
                }
            }
        }
    }

    private void handleUpdatingFacetVersion(Issue issue, String currFacetVersion) {
        ConfiguredSystem configuredSystem = issue.getConfiguredSystem();
        String prevFacetVersion = configuredSystem.getFacetVersion();
        if (StringUtils.isEmpty(prevFacetVersion) || !prevFacetVersion.equals(currFacetVersion)) {
            configuredSystem.setFacetVersion(currFacetVersion);
            if (configuredSystemService.save(configuredSystem)) {
                IssueComments comment = new IssueComments();
                comment.setIssueFk(issue.getId());
                comment.setComments("Upgraded FACET Version from " + prevFacetVersion + " to " + currFacetVersion
                        + " on " + configuredSystem.getComputerName());
                issueCommentsService.save(comment);
            }
        }
    }

    private void handleUpdatingOsVersion(Issue issue, String currOsVersion) {
        ConfiguredSystem configuredSystem = issue.getConfiguredSystem();
        String prevOsVersion = configuredSystem.getOsVersion();
        if (StringUtils.isEmpty(prevOsVersion) || !prevOsVersion.equals(currOsVersion)) {
            configuredSystem.setOsVersion(currOsVersion);
            if (configuredSystemService.save(configuredSystem)) {
                IssueComments comment = new IssueComments();
                comment.setIssueFk(issue.getId());
                comment.setComments("Upgraded OS Version from " + prevOsVersion + " to " + currOsVersion
                        + " on " + configuredSystem.getComputerName());
                issueCommentsService.save(comment);
            }
        }
    }

    public ArrayList<Issue> getByAtoFk(int atoFk) {
        try {
            return getDao().getByAtoFk(atoFk);
        }
        catch (Exception e) {
            logError("Could not getByAtoFk.", e);
        }
        return new ArrayList<>();
    }

    public ArrayList<Issue> getByPkArr(List<String> issuePkList) {
        try {
            return getDao().getByPkArr(issuePkList);
        }
        catch (Exception e) {
            logError("Could not issuePkArr.", e);
        }
        return new ArrayList<>();
    }

    public void handleBulkDeleteIssues(String[] issuePkArr) {
        if (issuePkArr == null || issuePkArr.length <= 0) {
            return;
        }
        @SuppressWarnings("unchecked")
        List<String> issuePkList = Arrays.asList(issuePkArr);
        for (String issuePk : issuePkList) {
            Integer issuePkInteger = StringUtils.parseInt(issuePk);
            if (issuePkInteger != null) {
                deleteById(issuePkInteger);
                // no need to cascade delete since it is automated using SQL
                // TRIGGER "delete_issue"
            }
        }
    }

    public void handleBulkCloseIssues(String[] issuePkArr, String resolution, String personAssigned) {
        if (issuePkArr == null || issuePkArr.length <= 0) {
            return;
        }
        @SuppressWarnings("unchecked")
        ArrayList<Issue> issueToCloseList = getByPkArr(Arrays.asList(issuePkArr));
        boolean success = true;
        for (Issue issue : issueToCloseList) {
            issue.setIssueStatus(IssueStatus.CLOSED_SUCCESSFUL);
            issue.setResolution(resolution);
            issue.setPersonAssigned(personAssigned);
            issue.setClosedDate(LocalDate.now());
            issue.setTotalTime(DEFAULT_ISSUE_TOTAL_TIME);
            if (!save(issue)) {
                success = false;
            }
        }
        if (success) {
            issueCommentsService.bulkAddComment(issueToCloseList, resolution);
        }
    }

    public int submitBulkIssueForm(BulkIssueForm bulkIssueForm, IssueCategoryService issueCategoryService,
            IssueCommentsService issueCommentsService, TransmittalService transmittalService,
            String currFacetVersion, String currOsVersion) {
        String[] includeConfiguredSystemPkArr = bulkIssueForm.getIncludeConfiguredSystemPkArr();
        if (includeConfiguredSystemPkArr == null || includeConfiguredSystemPkArr.length <= 0) {
            return 0;
        }
        int issueCount = 0;
        @SuppressWarnings("unchecked")
        List<String> pkList = Arrays.asList(includeConfiguredSystemPkArr);
        ArrayList<ConfiguredSystemWithIssues> configuredSystemList = configuredSystemService.getWithIssuesByPkList(pkList,
                transmittalService, this, currFacetVersion, currOsVersion, pocService);
        BulkIssueCategory category = bulkIssueForm.getCategory();
        int categoryCode = category.getCode();
        if (categoryCode != BulkIssueCategory.UNKNOWN.getCode()) {
            boolean isMonthlyEmail = categoryCode == BulkIssueCategory.MONTHLY_EMAIL.getCode();
            ArrayList<Issue> generatedIssueList = generateIssuesByConfiguredSystemList(issueCategoryService, bulkIssueForm,
                    configuredSystemList, isMonthlyEmail);
            if (isMonthlyEmail) {
                addCommentsToOpenMonthlyIssues(generatedIssueList, issueCommentsService);
            }
            insertIssuesWithComments(generatedIssueList, issueCommentsService);
            issueCount = generatedIssueList.size();
        }
        else {
            logError("Bulk Issue Category was not known.");
        }
        return issueCount;
    }

    /**
     * SupportModel //bulkInsertIssueComments(conn, getOpenIssuePkArr(conn,
     * shipPk, "FACET Update"), // "Reminder e-mail sent via Monthly E-Mail
     * Notification module", loginBean); //bulkInsertIssueComments(conn,
     * getOpenIssuePkArr(conn, shipPk, "RSupply Upgrade"), // "Reminder e-mail
     * sent via Monthly E-Mail Notification module", loginBean);
     * //bulkInsertIssueComments(conn, getOpenIssuePkArr(conn, shipPk, "ATO
     * Maintenance Release"), // "Reminder e-mail sent via Monthly E-Mail
     * Notification module", loginBean);
     * 
     * @param generatedIssueList
     */
    private void addCommentsToOpenMonthlyIssues(ArrayList<Issue> generatedIssueList, IssueCommentsService issueCommentsService) {
        List<Integer> shipPkList = new ArrayList<>();
        for (Issue issue : generatedIssueList) {
            shipPkList.add(issue.getShipFk());
        }
        List<String> categoryNameList = new ArrayList<>();
        categoryNameList.add(MonthlyIssueCategory.FACET.getName());
        categoryNameList.add(MonthlyIssueCategory.RSUPPLY.getName());
        categoryNameList.add(MonthlyIssueCategory.ATO.getName());

        ArrayList<Integer> issuePkList = getOpenedIssuePksByShipPksAndCategoryNames(shipPkList, categoryNameList);
        issueCommentsService.bulkAddComment(issuePkList, MONTHLY_EMAIL_COMMENT);
    }

    public ArrayList<Issue> getOpenedByShipPk(Integer shipPk) {
        try {
            return getDao().getOpenedByShipPk(shipPk);
        }
        catch (SqlSessionException e) {
            logError("Unable to getOpenedByShipPk shipPk='" + shipPk + "'.", e);
        }
        return new ArrayList<>();
    }

    public ArrayList<Integer> getOpenedIssuePksByShipPksAndCategoryNames(List<Integer> shipPkList, List<String> categoryNameList) {
        try {
            return getDao().getOpenedIssuePksByShipPksAndCategoryNames(shipPkList, categoryNameList);
        }
        catch (SqlSessionException e) {
            logError("Unable to getByCategory categoryName='" + categoryNameList + "'.", e);
        }
        return new ArrayList<>();
    }

    private void insertIssuesWithComments(ArrayList<Issue> issueList, IssueCommentsService issueCommentsService) {
        if (issueList == null || issueList.isEmpty()) {
            return;
        }
        ArrayList<IssueComments> allComments = new ArrayList<>();
        getUtilDao().commit();
        getUtilDao().beginImmediate();
        for (Issue issue : issueList) {
            if (save(issue)) {
                Integer id = issue.getId();
                ArrayList<IssueComments> issueCommentList = issue.getIssueCommentList();
                for (IssueComments comment : issueCommentList) {
                    comment.setIssueFk(id);
                    allComments.add(comment);
                }
            }
        }
        issueCommentsService.batchInsert(allComments);
    }

    public ArrayList<Issue> generateIssuesByConfiguredSystemList(IssueCategoryService issueCategoryService, BulkIssueForm bulkIssueForm,
            ArrayList<ConfiguredSystemWithIssues> configuredSystemList, boolean isMonthlyUpdate) {
        ArrayList<Issue> issueList = new ArrayList<>();
        for (ConfiguredSystemWithIssues cs : configuredSystemList) {
            if (isMonthlyUpdate) {
                Issue latestDmsIssue = createLatestDmsIssue(bulkIssueForm, issueCategoryService, cs);
                issueList.add(latestDmsIssue);

                Issue transmittalInactivityIssue = createTransmittalInactivityIssue(bulkIssueForm, issueCategoryService, cs);
                if (transmittalInactivityIssue != null) {
                    issueList.add(transmittalInactivityIssue);
                }

                Issue missingTransmittalsIssue = createMissingTransmittalsIssue(bulkIssueForm, issueCategoryService, cs);
                if (missingTransmittalsIssue != null) {
                    issueList.add(missingTransmittalsIssue);
                }
            }
            else {
                Issue issue = createOtherIssue(bulkIssueForm, issueCategoryService, cs);
                if (issue != null) {
                    issueList.add(issue);
                }
            }
        }
        return issueList;
    }

    private Issue createOtherIssue(BulkIssueForm bulkIssueForm, IssueCategoryService issueCategoryService, ConfiguredSystemWithIssues cs) {
        Issue issue = createBaseCsIssue(bulkIssueForm, cs);
        issue.setTitle(bulkIssueForm.getTitle() + " for " + cs.getComputerName());
        String categoryName = bulkIssueForm.getCategory().getName();
        IssueCategory issueCategory = getIssueCategoryByName(issueCategoryService, categoryName);
        if (issueCategory != null) {
            issue.setIssueCategory(issueCategory);
            issue.setIssueCategoryFk(issueCategory.getId());
        }
        IssueComments issueComment = createBaseIssueComment(bulkIssueForm);
        issueComment.setComments(bulkIssueForm.getComments());
        issue.getIssueCommentList().add(issueComment);
        return issue;
    }

    private Issue createLatestDmsIssue(BulkIssueForm bulkIssueForm, IssueCategoryService issueCategoryService,
            ConfiguredSystemWithIssues cs) {
        Issue latestDmsIssue = createBaseCsIssue(bulkIssueForm, cs);
        latestDmsIssue.setTitle(MONTHLY_EMAIL_NOTIF + "Latest DMS for " + cs.getComputerName());
        IssueCategory issueCategory = getIssueCategoryByName(issueCategoryService, MonthlyIssueCategory.DMS.getName());
        if (issueCategory != null) {
            latestDmsIssue.setIssueCategory(issueCategory);
            latestDmsIssue.setIssueCategoryFk(issueCategory.getId());
        }
        IssueComments issueComment = createBaseIssueComment(bulkIssueForm);
        issueComment.setComments(cs.getMonthlyEmailMessage());
        latestDmsIssue.getIssueCommentList().add(issueComment);
        return latestDmsIssue;
    }

    private Issue createTransmittalInactivityIssue(BulkIssueForm bulkIssueForm, IssueCategoryService issueCategoryService,
            ConfiguredSystemWithIssues cs) {
        if (cs.isTransmittalInactivity()) {
            Issue transInactivityIssue = createBaseCsIssue(bulkIssueForm, cs);
            transInactivityIssue.setTitle(MONTHLY_EMAIL_NOTIF + "Transmittal Inactivity for " + cs.getComputerName());
            IssueCategory issueCategory = getIssueCategoryByName(issueCategoryService, MonthlyIssueCategory.INACTIVITY.getName());
            if (issueCategory != null) {
                transInactivityIssue.setIssueCategory(issueCategory);
                transInactivityIssue.setIssueCategoryFk(issueCategory.getId());
            }
            IssueComments issueComment = createBaseIssueComment(bulkIssueForm);
            issueComment.setComments(cs.getMonthlyEmailMessage());
            transInactivityIssue.getIssueCommentList().add(issueComment);
            return transInactivityIssue;
        }
        return null;
    }

    private Issue createMissingTransmittalsIssue(BulkIssueForm bulkIssueForm, IssueCategoryService issueCategoryService,
            ConfiguredSystemWithIssues cs) {
        if (cs.isTransmittalInactivity()) {
            Issue missingTransIssue = createBaseCsIssue(bulkIssueForm, cs);
            missingTransIssue.setTitle(MONTHLY_EMAIL_NOTIF + "Missing LOGCOP Transmittals for " + cs.getComputerName());
            IssueCategory issueCategory = getIssueCategoryByName(issueCategoryService, MonthlyIssueCategory.MISSING_TRANSMITTALS.getName());
            if (issueCategory != null) {
                missingTransIssue.setIssueCategory(issueCategory);
                missingTransIssue.setIssueCategoryFk(issueCategory.getId());
            }
            IssueComments issueComment = createBaseIssueComment(bulkIssueForm);
            issueComment.setComments(cs.getMonthlyEmailMessage());
            missingTransIssue.getIssueCommentList().add(issueComment);
        }
        return null;
    }

    private IssueCategory getIssueCategoryByName(IssueCategoryService issueCategoryService, String categoryName) {
        if (nameToIssueCategoryMap == null) {
            nameToIssueCategoryMap = new HashMap<>();
            ArrayList<IssueCategory> all = issueCategoryService.getAll();
            for (IssueCategory issueCategory : all) {
                nameToIssueCategoryMap.put(issueCategory.getCategory(), issueCategory);
            }
        }
        IssueCategory issueCategory = nameToIssueCategoryMap.get(categoryName);
        if (issueCategory == null) {
            logError("Issue Category '" + categoryName + "' not found.");
        }
        return issueCategory;
    }

    private IssueComments createBaseIssueComment(BulkIssueForm bulkIssueForm) {
        IssueComments issueComment = new IssueComments();
        issueComment.setCreatedBy(bulkIssueForm.getOpenedBy());
        issueComment.setCreatedDate(LocalDateTime.now());
        return issueComment;
    }

    private Issue createBaseCsIssue(BulkIssueForm bulkIssueForm, ConfiguredSystemWithIssues cs) {
        Issue issue = createBaseIssue(bulkIssueForm);
        issue.setShipFk(cs.getShipFk());
        issue.setShip(cs.getShip());
        issue.setConfiguredSystemFk(cs.getId());
        issue.setConfiguredSystem(cs);
        issue.setDept(BULK_ISSUE_DEPT);
        return issue;
    }

    private Issue createBaseIssue(BulkIssueForm bulkIssueForm) {
        Integer projectFk = bulkIssueForm.getProjectFk();
        String personAssigned = bulkIssueForm.getPersonAssigned();
        String openedBy = bulkIssueForm.getOpenedBy();
        LocalDate openedDate = bulkIssueForm.getOpenedDate();
        String status = bulkIssueForm.getStatus();
        LocalDate autoCloseDate = bulkIssueForm.getAutoCloseDate();
        String autoCloseToStatus = bulkIssueForm.getAutoCloseToStatus();
        // String totalTime = bulkIssueForm.getTotalTime();

        Issue issue = new Issue();
        issue.setProjectFk(projectFk);
        issue.setPersonAssigned(personAssigned);
        issue.setOpenedBy(openedBy);
        issue.setOpenedDate(openedDate);
        issue.setStatus(status);
        issue.setInitiatedBy("PSHI");
        issue.setIsEmailSent("Y");
        issue.setDescription(BULK_ISSUE_DESCRIPTION);
        issue.setAutoCloseDate(autoCloseDate);
        issue.setAutoCloseStatus(autoCloseToStatus);

        IssueComments issueComments = createBaseIssueComment(bulkIssueForm);
        issueComments.setComments("Support issue created");
        issue.getIssueCommentList().add(issueComments);
        return issue;
    }

    public Map<Integer, ArrayList<String>> getCsPkToMissingAtoMap() {
        Map<Integer, ArrayList<String>> map = new HashMap<>();
        List<FkAndStringList> configuredSysemsWithAtoIssues = getConfiguredSystemOpenAtoIssues();
        for (FkAndStringList csWithAtoIssues : configuredSysemsWithAtoIssues) {
            Integer configuredSystemFk = csWithAtoIssues.getFk();
            ArrayList<String> atoDateStrList = csWithAtoIssues.getStringList();
            map.put(configuredSystemFk, atoDateStrList);
        }
        return map;
    }

    private ArrayList<FkAndStringList> getConfiguredSystemOpenAtoIssues() {
        try {
            return getDao().getConfiguredSystemOpenAtoIssues();
        }
        catch (Exception e) {
            logError("Unable to getOpenAtoIssues.", e);
        }
        return new ArrayList<>();
    }

    /**
     * @param categoryNames
     * @return
     */
    public ArrayList<Issue> getOpenByCategoryNames(List<String> categoryNames) {
        try {
            return getDao().getOpenByCategoryNames(categoryNames);
        }
        catch (Exception e) {
            logError("Unable to getOpenAtoIssues.", e);
        }
        return new ArrayList<>();
    }

    public ArrayList<Issue> getOpenMonthlyIssues() {
        return getOpenByCategoryNames(MonthlyIssueCategory.getAllNames());
    }

    public IssueSupportVisit getLastSupportVisitByShipFk(Integer shipPk) {
        try {
            return getDao().getLastSupportVisitByShipFk(shipPk);
        }
        catch (Exception e) {
            logError("Unable to getLastSupportVisitByShipFk. shipPk=" + shipPk, e);
        }
        return null;
    }

    public void autoCloseIssues() {
        try {
            Integer count = getDao().getAutoCloseIssueCount();
            if (count != null && count > 0) {
                getDao().autoCloseIssues();
                logInfo("Successfully auto closed issues.");
            }
        }
        catch (Exception e) {
            logError("Unable to autoCloseIssues.", e);
        }
    }
}
